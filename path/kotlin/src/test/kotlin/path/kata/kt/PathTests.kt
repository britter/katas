/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package path.kata.kt

import arrow.core.Left
import arrow.core.Right
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertNull
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.TestInstance
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.Arguments
import org.junit.jupiter.params.provider.Arguments.arguments
import org.junit.jupiter.params.provider.MethodSource

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class PathTests {

    fun points(): List<Arguments> = listOf(
        arguments(Point(0, 0), Point(0, 0), 0.0),
        arguments(Point(0, 0), Point(1, 0), 1.0),
        arguments(Point(1, 0), Point(2, 0), 1.0),
        arguments(Point(1, 0), Point(0, 0), 1.0),
        arguments(Point(0, 0), Point(0, 1), 1.0),
        arguments(Point(0, 0), Point(5, 12), 13.0)
    )

    @MethodSource("points")
    @ParameterizedTest
    fun `computes distance of a segment`(origin: Point, destination: Point, expectedDistance: Double) =
        assertEquals(expectedDistance, distance(Segment(origin, destination)))

    fun segments() = listOf(
        arguments(Path(), 0.0),
        arguments(Path(Segment(Point(0, 0), Point(1, 0))), 1.0),
        arguments(Path(Segment(Point(0, 0), Point(1, 0)), Segment(Point(1, 0), Point(1, 1))), 2.0)
    )

    @MethodSource("segments")
    @ParameterizedTest
    fun `computes distance of a path`(path: Path, expectedDistance: Double) =
        assertEquals(expectedDistance, distance(path))

    @Test
    fun `computes the shortest path`() {
        val a = Path(Segment(Point(0, 0), Point(0, 1)))
        val b = Path(Segment(Point(0, 0), Point(0, 2)))

        assertEquals(a, shortestPath(a, b))
        assertEquals(a, shortestPath(b, a))
    }

    @Test
    fun `computes the shortest path for a given set of stops`() {
        val a = Path(Segment(Point(0, 0), Point(1, 1)), Segment(Point(1, 1), Point(2, 2)))
        val b = Path(Segment(Point(0, 0), Point(0, 2)), Segment(Point(0, 2), Point(2, 2)))

        assertEquals(b, shortestPath(a, b, stops = setOf(Point(0, 2))))
    }

    @Test
    fun `shortest path of no paths is null`() =
        assertNull(shortestPath(stops = setOf(Point(0, 1))))

    @Test
    fun `can not construct non consecutive paths`() =
        assertEquals(
            Left(InconsecutivePath),
            path(Segment(Point(0, 0), Point(1, 1)), Segment(Point(5, 5), Point(3, 3)))
        )

    @Test
    fun `can construct consecutive paths`() {
        val segments = listOf(Segment(Point(0, 0), Point(0, 1)), Segment(Point(0, 1), Point(2, 2)))
        assertEquals(Right(segments), path(*segments.toTypedArray()).map { it.segments })
    }

    @Test
    fun `computes all possible paths between two points`() {
        val origin = Point(0, 0)
        val destination = Point(2, 2)
        val segments = setOf(
            Segment(Point(0, 0), Point(2, 2)),
            Segment(Point(0, 0), Point(2, 0)),
            Segment(Point(2, 0), Point(2, 2))
        )

        assertEquals(
            setOf(
                Path(Segment(Point(0, 0), Point(2, 2))),
                Path(Segment(Point(0, 0), Point(2, 0)), Segment(Point(2, 0), Point(2, 2)))
            ),
            allPaths(origin, destination, segments)
        )
    }

    @Test
    fun `computes no paths if no path between points exist and segments form a cycle`() {
        val origin = Point(0, 0)
        val destination = Point(2, 2)
        val segments = setOf(
            Segment(Point(0, 0), Point(1, 0)),
            Segment(Point(1, 0), Point(1, 1)),
            Segment(Point(1, 1), Point(0, 1)),
            Segment(Point(0, 1), Point(0, 0))
        )

        assertEquals(
            emptySet<Path>(),
            allPaths(origin, destination, segments)
        )
    }

    @Test
    fun `computes all possible paths between two points with cycles`() {
        val origin = Point(0, 0)
        val destination = Point(1, 1)
        val segments = setOf(
            Segment(Point(0, 0), Point(1, 0)),
            Segment(Point(1, 0), Point(1, 1)),
            Segment(Point(1, 1), Point(0, 1)),
            Segment(Point(0, 1), Point(0, 0))
        )

        assertEquals(
            setOf(Path(Segment(Point(0, 0), Point(1, 0)), Segment(Point(1, 0), Point(1, 1)))),
            allPaths(origin, destination, segments)
        )
    }
}
